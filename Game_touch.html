<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <title>复数计算器游戏</title>
    <style>
        /* CSS styles remain largely the same as provided in Game.html */
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden; /* 防止背景图导致滚动条 */
            user-select: none; /* 禁止选择文本 */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE/Edge */
            touch-action: none; /* Prevent default touch actions like scrolling/zooming on the body */
        }

        .background-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-image: url('images/Background.png');
            background-size: cover;
            background-position: center;
            opacity: 0.7;
            z-index: -1;
        }

        #game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.85); /* 轻微透明的白色背景，让内容更清晰 */
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            width: 90%;
            max-width: 1200px; /* 限制最大宽度 */
        }

        #start-button {
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            border: none;
            background-color: #4CAF50;
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: background-color 0.3s;
        }
        #start-button:hover {
            background-color: #45a049;
        }

        #game-container {
            display: none; /* 初始隐藏 */
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px; /* 限制顶部栏宽度 */
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: bold;
        }
        #timer { color: #d9534f; }
        #score { color: #5cb85c; } /* 如果需要分数的话 */

        #main-game-area {
            display: flex;
            justify-content: center; /* 水平居中对齐 */
            align-items: flex-start; /* 顶部对齐 */
            gap: 30px; /* 各区域之间的间隙 */
            width: 100%;
            margin-bottom: 20px;
        }

        /* 数字表格区域 */
        #numbers-table-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3列 */
            grid-template-rows: repeat(7, auto);    /* 7行 */
            gap: 10px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
        }

        .number-cell, .operator-item, .expression-slot .slot-content {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 50px; /* 固定高度 */
            width: 100px; /* 高度的2倍 */
            background-color: #ffffff;
            border: 1px solid #cccccc;
            border-radius: 6px;
            cursor: grab;
            font-size: 16px;
            text-align: center;
            box-sizing: border-box;
            overflow: hidden; /* 防止内容溢出 */
            padding: 5px;
            touch-action: none; /* Important for touch drag */
        }
        .number-cell:empty { /* 空单元格样式 */
            background-color: #e9e9e9;
            cursor: default;
            touch-action: auto; /* Allow default actions on empty cells */
        }
        .number-cell.occupied {
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }


        /* 运算符区域 */
        #operators-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 8px;
        }
        .operator-item {
            width: 50px; /* 运算符窄一点 */
            height: 50px;
            font-size: 24px;
            font-weight: bold;
        }

        /* 运算表达式区域 */
        #expression-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px; /* 矩形和圆形之间的间隔 */
            padding: 10px;
            background-color: #e0e0e0;
            border-radius: 8px;
        }

        /* 表达式行容器 */
        .expression-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .expression-slot {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px dashed #bbbbbb;
            background-color: #f9f9f9;
            box-sizing: border-box;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out; /* Added transition for highlighting */
        }
        .expression-slot.number-slot { /* 矩形 */
            width: 100px;
            height: 50px;
            border-radius: 6px;
        }
        .expression-slot.operator-slot { /* 圆形 */
            width: 50px;
            height: 50px;
            border-radius: 50%;
        }
        .expression-slot .slot-content { /* 拖入后内容的样式 */
            width: 100%;
            height: 100%;
            border: 1px solid transparent; /* 保持尺寸 */
            background-color: #fff; /* 拖入后背景 */
            cursor: default; /* 拖入后不可再抓取 */
            touch-action: auto; /* Allow default actions on content inside slot */
        }
         .expression-slot.operator-slot .slot-content {
            font-size: 24px;
            font-weight: bold;
         }
        .expression-slot.drag-over { /* Style for highlighting drop target */
            background-color: #dff0d8; /* Light green background */
            border-color: #5cb85c; /* Green border */
        }


        /* 消息提示区域 */
        #message-area {
            margin-top: 15px; /* 与表达式区域的间隔 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            min-height: 100px; /* Ensure space for messages */
        }
        #message-text {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        #message-image {
            max-width: 300px; /* 增大图片尺寸 */
            max-height: 150px; /* 增大图片尺寸 */
            width: 80%; /* 相对于容器的宽度 */
            object-fit: contain; /* 保持图片比例 */
        }

        /* 拖拽时的克隆元素样式 */
        .dragging-clone {
            position: absolute;
            opacity: 0.8;
            pointer-events: none; /* 重要：允许下方元素接收drop/touch事件 */
            z-index: 1000;
            transform: scale(1.1); /* 轻微放大 */
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s; /* 添加过渡效果 */
            /* Ensure clone inherits styles */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #ffffff;
            border: 1px solid #cccccc;
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
            box-sizing: border-box;
            overflow: hidden;
            padding: 5px;
        }
        .dragging-clone.operator-clone { /* Specific style for operator clone */
             width: 50px;
             height: 50px;
             font-size: 24px;
             font-weight: bold;
        }
        .dragging-clone.number-clone { /* Specific style for number clone */
             width: 100px;
             height: 50px;
        }

        .dragging-source { /* 原始拖拽元素的样式 */
            opacity: 0.4;
        }

        /* 复数和分数显示样式 */
        .complex-num-val {
            display: flex;
            flex-direction: row; /* 水平排列实部、符号、虚部 */
            align-items: center;
            justify-content: center;
            flex-wrap: wrap; /* 允许换行 */
            line-height: 1.2; /* 调整行高以适应分数 */
            width: 100%;
            height: 100%;
            overflow-wrap: break-word; /* 允许长单词/数字换行 */
            word-break: break-all;
        }
        .complex-num-val > * { /* 实部、符号、虚部之间的间距 */
            margin: 0 2px;
        }
        .fraction-display {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            vertical-align: middle;
            margin: 0 1px; /* 分数与其他部分的微小间距 */
        }
        .numerator {
            font-size: 0.9em;
            padding: 0 2px;
            border-bottom: 1.5px solid currentColor;
        }
        .denominator {
            font-size: 0.9em;
            padding: 0 2px;
        }
        .complex-num-val .operator-sign { /* 复数中间的加减号 */
            font-size: 1em;
            font-weight: bold;
        }
        .complex-num-val i { /* i的样式 */
            font-style: italic;
            margin-left: 1px;
        }

        /* 响应式调整 */
        @media (max-width: 768px) {
            #game-wrapper {
                width: 95%;
                padding: 10px;
            }
            #main-game-area {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            #numbers-table-container {
                grid-template-columns: repeat(3, 1fr); /* 保持3列，但宽度会变小 */
            }
            .number-cell, .expression-slot.number-slot .slot-content, .dragging-clone.number-clone {
                height: 40px;
                width: 80px; /* 保持2倍关系 */
                font-size: 14px;
            }
            .operator-item, .expression-slot.operator-slot .slot-content, .dragging-clone.operator-clone {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
             .expression-slot.number-slot {
                width: 80px;
                height: 40px;
            }
            .expression-slot.operator-slot {
                width: 40px;
                height: 40px;
            }
            #expression-area {
                flex-wrap: wrap; /* 允许表达式换行 */
                justify-content: center;
            }
            #top-bar {
                font-size: 16px;
                flex-direction: column;
                align-items: center;
                gap: 5px;
            }
            #message-image {
                max-width: 200px; /* 小屏幕上缩小图片 */
                max-height: 100px;
            }
        }

    </style>
</head>
<body>
    <div class="background-overlay"></div>
    <div id="game-wrapper">
        <button id="start-button">开始游戏</button>
        <div id="game-container">
            <div id="top-bar">
                <div id="timer">时间: 90s</div>
            </div>

            <div id="main-game-area">
                <div id="numbers-table-container">
                    </div>

                <div id="operators-list">
                    <div class="operator-item" draggable="true" data-op="+">+</div>
                    <div class="operator-item" draggable="true" data-op="-">-</div>
                    <div class="operator-item" draggable="true" data-op="*">×</div>
                    <div class="operator-item" draggable="true" data-op="/">÷</div>
                </div>

                <div id="expression-area">
                    <div class="expression-row">
                        <div class="expression-slot number-slot" id="operand1-slot" data-slot-type="operand"></div>
                        <div class="expression-slot operator-slot" id="operator-slot" data-slot-type="operator"></div>
                        <div class="expression-slot number-slot" id="operand2-slot" data-slot-type="operand"></div>
                    </div>
                    <div id="message-area">
                        <div id="message-text"></div>
                        <img id="message-image" src="" alt="" style="display:none;"/>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Complex Number Class (Unchanged) ---
        class Complex {
            constructor(realNum = 0, realDen = 1, imagNum = 0, imagDen = 1) {
                this.real = { num: parseInt(realNum), den: parseInt(realDen) };
                this.imag = { num: parseInt(imagNum), den: parseInt(imagDen) };
                this.simplify();
            }

            static gcd(a, b) {
                a = Math.abs(a);
                b = Math.abs(b);
                while (b) {
                    [a, b] = [b, a % b];
                }
                return a;
            }

            simplifyPart(part) {
                if (part.den === 0) {
                    part.num = (part.num > 0) ? Infinity : (part.num < 0) ? -Infinity : 0;
                    part.den = 1;
                    return;
                }
                if (part.num === 0) {
                    part.den = 1;
                    return;
                }
                const common = Complex.gcd(part.num, part.den);
                part.num /= common;
                part.den /= common;
                if (part.den < 0) {
                    part.num *= -1;
                    part.den *= -1;
                }
            }

            simplify() {
                this.simplifyPart(this.real);
                this.simplifyPart(this.imag);
                if (this.real.num === 0 && this.imag.num === 0) {
                    this.real = { num: 0, den: 1 };
                    this.imag = { num: 0, den: 1 };
                }
            }

            add(other) {
                const realNum = this.real.num * other.real.den + other.real.num * this.real.den;
                const realDen = this.real.den * other.real.den;
                const imagNum = this.imag.num * other.imag.den + other.imag.num * this.imag.den;
                const imagDen = this.imag.den * other.imag.den;
                return new Complex(realNum, realDen, imagNum, imagDen);
            }

            subtract(other) {
                const realNum = this.real.num * other.real.den - other.real.num * this.real.den;
                const realDen = this.real.den * other.real.den;
                const imagNum = this.imag.num * other.imag.den - other.imag.num * this.imag.den;
                const imagDen = this.imag.den * other.imag.den;
                return new Complex(realNum, realDen, imagNum, imagDen);
            }

            multiply(other) {
                const ac_num = this.real.num * other.real.num;
                const ac_den = this.real.den * other.real.den;
                const bd_num = this.imag.num * other.imag.num;
                const bd_den = this.imag.den * other.imag.den;
                const realPartNum = ac_num * bd_den - bd_num * ac_den;
                const realPartDen = ac_den * bd_den;
                const ad_num = this.real.num * other.imag.num;
                const ad_den = this.real.den * other.imag.den;
                const bc_num = this.imag.num * other.real.num;
                const bc_den = this.imag.den * other.real.den;
                const imagPartNum = ad_num * bc_den + bc_num * ad_den;
                const imagPartDen = ad_den * bc_den;
                return new Complex(realPartNum, realPartDen, imagPartNum, imagPartDen);
            }

            divide(other) {
                if (other.real.num === 0 && other.real.den === 1 && other.imag.num === 0 && other.imag.den === 1) {
                    console.error("Division by zero");
                    return new Complex(NaN, 1, NaN, 1);
                }
                const conjugateOther = new Complex(other.real.num, other.real.den, -other.imag.num, other.imag.den);
                const numerator = this.multiply(conjugateOther);
                const c_squared_num = other.real.num * other.real.num;
                const c_squared_den = other.real.den * other.real.den;
                const d_squared_num = other.imag.num * other.imag.num;
                const d_squared_den = other.imag.den * other.imag.den;
                const denominator_val_num = c_squared_num * d_squared_den + d_squared_num * c_squared_den;
                const denominator_val_den = c_squared_den * d_squared_den;
                if (denominator_val_num === 0) {
                     console.error("Division resulted in zero denominator");
                     return new Complex(NaN,1,NaN,1);
                }
                const res_real_num = numerator.real.num * denominator_val_den;
                const res_real_den = numerator.real.den * denominator_val_num;
                const res_imag_num = numerator.imag.num * denominator_val_den;
                const res_imag_den = numerator.imag.den * denominator_val_num;
                return new Complex(res_real_num, res_real_den, res_imag_num, res_imag_den);
            }

            equals(other) {
                this.simplify();
                other.simplify();
                return this.real.num === other.real.num && this.real.den === other.real.den &&
                       this.imag.num === other.imag.num && this.imag.den === other.imag.den;
            }

            toHTMLString() {
                this.simplify();
                const R = this.real;
                const I = this.imag;

                if (R.num === 0 && I.num === 0) return '<div class="complex-num-val">0</div>';
                if (isNaN(R.num) || isNaN(I.num)) return '<div class="complex-num-val" style="color:red;">错误</div>';

                let html = '';
                const createFractionHTML = (num, den) => {
                    return `<div class="fraction-display"><span class="numerator">${Math.abs(num)}</span><span class="denominator">${den}</span></div>`;
                };

                if (R.num !== 0) {
                    if (R.num < 0) html += '-';
                    if (R.den === 1) html += Math.abs(R.num);
                    else html += createFractionHTML(R.num, R.den);
                }

                if (I.num !== 0) {
                    if (R.num !== 0 && I.num > 0) html += '<span class="operator-sign">+</span>';
                    if (I.num < 0) html += (R.num !== 0 ? '<span class="operator-sign">-</span>' : '-');

                    const absImagNum = Math.abs(I.num);
                    if (I.den === 1) {
                        if (absImagNum !== 1) html += absImagNum;
                        html += '<i>i</i>';
                    } else {
                        html += createFractionHTML(absImagNum, I.den);
                        html += '<i>i</i>';
                    }
                }
                // Include data attributes in the wrapper div for easy access
                return `<div class="complex-num-val" data-real-num="${R.num}" data-real-den="${R.den}" data-imag-num="${I.num}" data-imag-den="${I.den}">${html}</div>`;
            }
        }

        // --- Game Logic ---
        const startGameButton = document.getElementById('start-button');
        const gameContainer = document.getElementById('game-container');
        const timerDisplay = document.getElementById('timer');
        const numbersTableContainer = document.getElementById('numbers-table-container');
        const operatorsList = document.getElementById('operators-list'); // Get operators container
        const operand1Slot = document.getElementById('operand1-slot');
        const operand2Slot = document.getElementById('operand2-slot');
        const operatorSlot = document.getElementById('operator-slot');
        const messageText = document.getElementById('message-text');
        const messageImage = document.getElementById('message-image');
        const expressionSlots = [operand1Slot, operatorSlot, operand2Slot]; // Array of slots

        let timeLeft = 90;
        let timerInterval;
        let discoveredNumbers = [];
        let nextNumberCellIndex = 0;
        const totalNumberCells = 7 * 3;
        let expression = { operand1: null, operator: null, operand2: null };

        // --- Drag State Variables (Unified for Mouse & Touch) ---
        let isDragging = false;
        let draggedElement = null; // The actual element being dragged (number or operator)
        let draggedElementClone = null; // The visual clone following cursor/finger
        let dragOffsetX = 0; // Offset for positioning clone relative to pointer
        let dragOffsetY = 0;
        let currentDropTarget = null; // The slot currently being hovered over


        function initGame() {
            numbersTableContainer.innerHTML = ''; // Clear previous cells
            for (let i = 0; i < totalNumberCells; i++) {
                const cell = document.createElement('div');
                cell.classList.add('number-cell');
                cell.dataset.index = i;
                // Drop listeners for mouse (dragover/drop) are added to slots only
                numbersTableContainer.appendChild(cell);
            }

            discoveredNumbers = [];
            nextNumberCellIndex = 0;
            timeLeft = 90;
            timerDisplay.textContent = `时间: ${timeLeft}s`;
            clearExpressionSlots();
            hideMessage();

            // Add initial 'i'
            const initialI = new Complex(0, 1, 1, 1);
            addNumberToTable(initialI);

            // Add event listeners to operators
            operatorsList.querySelectorAll('.operator-item').forEach(addDraggableListeners);

             // Add event listeners to drop slots (for mouse)
            expressionSlots.forEach(slot => {
                slot.addEventListener('dragover', handleDragOverMouse);
                slot.addEventListener('dragleave', handleDragLeaveMouse);
                slot.addEventListener('drop', handleDropMouse);
            });
        }

        function addDraggableListeners(element) {
            // Mouse Events
            element.addEventListener('dragstart', handleDragStartMouse);
            element.addEventListener('dragend', handleDragEndMouse);
            // Touch Events
            element.addEventListener('touchstart', handleTouchStart, { passive: false }); // Need preventDefault
            // Move and End listeners are added to document during drag
        }

        function startGame() {
            startGameButton.style.display = 'none';
            gameContainer.style.display = 'flex';
            initGame();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            timeLeft--;
            timerDisplay.textContent = `时间: ${timeLeft}s`;
            if (timeLeft <= 0) {
                endGame();
            }
        }

        function endGame() {
            clearInterval(timerInterval);
            timerDisplay.textContent = "时间到！";
            // Disable further interactions by removing listeners or setting flags
            isDragging = false; // Ensure no lingering drag state
            cleanupDragState(); // Remove clone if any
            document.querySelectorAll('[draggable="true"]').forEach(el => {
                el.removeEventListener('dragstart', handleDragStartMouse);
                el.removeEventListener('dragend', handleDragEndMouse);
                el.removeEventListener('touchstart', handleTouchStart);
                el.setAttribute('draggable', 'false'); // Also visually indicate non-draggable
                el.style.cursor = 'default';
            });
             // Remove global touch listeners if they exist
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
            document.removeEventListener('mousemove', handleMouseMove); // If mouse clone positioning was added
            document.removeEventListener('mouseup', handleMouseUp); // If mouse clone positioning was added
        }

        function addNumberToTable(complexNum) {
            const alreadyExists = discoveredNumbers.some(existingNum => existingNum.equals(complexNum));
            if (alreadyExists) {
                return false;
            }

            if (nextNumberCellIndex < totalNumberCells) {
                discoveredNumbers.push(complexNum);
                const cell = numbersTableContainer.children[nextNumberCellIndex];
                if (cell) {
                    cell.innerHTML = complexNum.toHTMLString();
                    cell.setAttribute('draggable', 'true');
                    cell.dataset.type = 'number';
                    cell.complexValue = complexNum; // Attach object directly
                    cell.classList.add('occupied');
                    addDraggableListeners(cell); // Add both mouse and touch listeners
                    nextNumberCellIndex++;
                }
                return true;
            } else {
                console.warn("Table is full. Cannot add new number.");
                showMessage("表格已满，无法添加新数！", null); // Inform user
                return false;
            }
        }

        function showMessage(text, imageUrl, autoClear = true) {
            messageText.textContent = text;
            messageText.style.opacity = '1'; // Make sure text is visible
            if (imageUrl) {
                messageImage.src = imageUrl;
                messageImage.style.display = 'block';
                messageImage.style.opacity = '0';
                setTimeout(() => {
                    messageImage.style.transition = 'opacity 0.5s ease-in-out';
                    messageImage.style.opacity = '1';
                }, 10);
            } else {
                messageImage.style.display = 'none';
            }
            // Clear previous timeouts if any
            if (messageImage.clearTimeout) clearTimeout(messageImage.clearTimeout);
            if (messageText.clearTimeout) clearTimeout(messageText.clearTimeout);

            if (autoClear) {
                 messageText.clearTimeout = setTimeout(() => {
                     messageText.style.opacity = '0'; // Fade out text
                     setTimeout(() => messageText.textContent = '', 500); // Clear after fade
                 }, 2000); // Display for 2 seconds

                if (imageUrl) {
                    messageImage.clearTimeout = setTimeout(() => {
                        messageImage.style.opacity = '0';
                        setTimeout(() => {
                            messageImage.style.display = 'none';
                            messageImage.src = '';
                        }, 500); // Clear after fade
                    }, 2000); // Display for 2 seconds
                }
            }
        }

        function hideMessage() {
            // Clear any pending timeouts
             if (messageImage.clearTimeout) clearTimeout(messageImage.clearTimeout);
             if (messageText.clearTimeout) clearTimeout(messageText.clearTimeout);
            // Immediately hide
            messageText.textContent = '';
            messageText.style.opacity = '1'; // Reset opacity
            messageImage.style.display = 'none';
            messageImage.src = '';
            messageImage.style.opacity = '1'; // Reset opacity
        }

        // --- Unified Drag Start Logic ---
        function startDragging(element, clientX, clientY) {
            if (isDragging) return; // Prevent starting a new drag if one is in progress

            isDragging = true;
            draggedElement = element;
            draggedElement.classList.add('dragging-source');

            // Create Clone
            draggedElementClone = draggedElement.cloneNode(true);
            draggedElementClone.classList.add('dragging-clone');
             // Add specific clone class based on type for sizing
            if (draggedElement.dataset.type === 'number') {
                draggedElementClone.classList.add('number-clone');
            } else if (draggedElement.dataset.op) {
                draggedElementClone.classList.add('operator-clone');
            }
            document.body.appendChild(draggedElementClone);

            // Calculate offset from top-left corner of the element
            const rect = draggedElement.getBoundingClientRect();
            dragOffsetX = clientX - rect.left;
            dragOffsetY = clientY - rect.top;

            // Position the clone immediately
            updateClonePosition(clientX, clientY);
        }

        // --- Unified Clone Position Update ---
        function updateClonePosition(clientX, clientY) {
            if (draggedElementClone) {
                // Position based on pointer coordinates minus the initial offset
                draggedElementClone.style.left = `${clientX - dragOffsetX}px`;
                draggedElementClone.style.top = `${clientY - dragOffsetY}px`;
            }
        }

        // --- Unified Drag Move Logic (finding target) ---
        function handleDragMove(clientX, clientY) {
            if (!isDragging) return;

            updateClonePosition(clientX, clientY);

            // Hide clone temporarily to find element underneath
            draggedElementClone.style.display = 'none';
            const elementUnderPointer = document.elementFromPoint(clientX, clientY);
            draggedElementClone.style.display = ''; // Show clone again

            let potentialTarget = null;
            if (elementUnderPointer) {
                // Check if the element or its parent is a drop slot
                potentialTarget = elementUnderPointer.closest('.expression-slot');
            }

            // Remove highlight from previous target if it's different
            if (currentDropTarget && currentDropTarget !== potentialTarget) {
                currentDropTarget.classList.remove('drag-over');
            }

            // Add highlight to new target if valid
            if (potentialTarget && isDropAllowed(draggedElement, potentialTarget)) {
                potentialTarget.classList.add('drag-over');
                currentDropTarget = potentialTarget;
            } else {
                currentDropTarget = null; // No valid target under pointer
            }
        }

        // --- Unified Drop Logic ---
        function processDrop(targetSlot) {
            if (!isDragging || !draggedElement || !targetSlot) {
                cleanupDragState();
                return;
            }

            if (isDropAllowed(draggedElement, targetSlot)) {
                const isNumberDrag = draggedElement.dataset.type === 'number';
                const isOperatorDrag = !!draggedElement.dataset.op;
                const slotType = targetSlot.dataset.slotType;

                // Create content div for the slot
                const contentDiv = document.createElement('div');
                contentDiv.classList.add('slot-content');

                if (slotType === 'operand' && isNumberDrag) {
                    contentDiv.innerHTML = draggedElement.innerHTML; // Copy visual content
                    targetSlot.innerHTML = ''; // Clear previous content
                    targetSlot.appendChild(contentDiv);
                    // Update expression state
                    if (targetSlot.id === 'operand1-slot') {
                        expression.operand1 = draggedElement.complexValue;
                    } else if (targetSlot.id === 'operand2-slot') {
                        expression.operand2 = draggedElement.complexValue;
                    }
                } else if (slotType === 'operator' && isOperatorDrag) {
                    // Use original text content for display
                    contentDiv.textContent = draggedElement.textContent;
                    targetSlot.innerHTML = '';
                    targetSlot.appendChild(contentDiv);
                    // Update expression state with logical operator value
                    expression.operator = draggedElement.dataset.op;
                }

                checkAndCalculate(); // Attempt calculation
            }

            cleanupDragState();
        }

        // --- Unified Drag End/Cleanup ---
        function cleanupDragState() {
            if (draggedElement) {
                draggedElement.classList.remove('dragging-source');
            }
            if (draggedElementClone) {
                document.body.removeChild(draggedElementClone);
            }
            if (currentDropTarget) {
                currentDropTarget.classList.remove('drag-over');
            }
            isDragging = false;
            draggedElement = null;
            draggedElementClone = null;
            currentDropTarget = null;
            dragOffsetX = 0;
            dragOffsetY = 0;

            // Remove global listeners added during drag
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
        }

        // --- Helper to check if drop is valid ---
        function isDropAllowed(draggedEl, targetSlot) {
            if (!draggedEl || !targetSlot) return false;
            const isNumberDrag = draggedEl.dataset.type === 'number';
            const isOperatorDrag = !!draggedEl.dataset.op;
            const slotType = targetSlot.dataset.slotType;

            return (slotType === 'operand' && isNumberDrag) || (slotType === 'operator' && isOperatorDrag);
        }

        // --- Mouse Event Handlers ---
        function handleDragStartMouse(event) {
            // Prevent default HTML5 drag image
            event.dataTransfer.setDragImage(new Image(), 0, 0);
            event.dataTransfer.effectAllowed = 'move';

            // Use unified start function
            startDragging(event.target, event.clientX, event.clientY);

            // Add move/end listeners specific to mouse drag *if needed*
            // (handleDragMove covers general movement, but specific mouseup might be needed)
            // document.addEventListener('mousemove', handleMouseMove); // Potentially needed if clone lags
             document.addEventListener('mouseup', handleMouseUp, { once: true }); // Clean up on mouse up
        }

        function handleMouseMove(event) {
             // Optional: Could be used for smoother clone positioning with mouse if needed
             // handleDragMove(event.clientX, event.clientY);
        }
        function handleMouseUp(event) {
            // If mouseup happens outside a drop target, just clean up
            if (isDragging && !currentDropTarget) {
                 cleanupDragState();
            }
            // Drop logic is handled by handleDropMouse if over target
        }


        function handleDragOverMouse(event) {
            event.preventDefault(); // Allow drop
            // Highlight target using unified move logic
            handleDragMove(event.clientX, event.clientY);
        }

        function handleDragLeaveMouse(event) {
             // If the mouse leaves the slot area, remove highlight *if* it's not moving to another part of the same slot
             const relatedTarget = event.relatedTarget;
             if (!event.currentTarget.contains(relatedTarget)) {
                  if (currentDropTarget === event.currentTarget) {
                      currentDropTarget.classList.remove('drag-over');
                      currentDropTarget = null;
                  }
             }
        }

        function handleDropMouse(event) {
            event.preventDefault();
            const targetSlot = event.currentTarget;
            processDrop(targetSlot); // Use unified drop function
        }

        function handleDragEndMouse(event) {
            // Cleanup is handled by processDrop or mouseup/touchend
            // This might still be needed if the drag ends unexpectedly (e.g., Esc key)
             if (isDragging) { // If drop didn't happen
                 cleanupDragState();
             }
        }


        // --- Touch Event Handlers ---
        function handleTouchStart(event) {
            // Prevent default touch actions like scrolling
            event.preventDefault();

            if (event.touches.length === 1) {
                const touch = event.touches[0];
                startDragging(event.currentTarget, touch.clientX, touch.clientY); // Use currentTarget

                // Add global listeners for move and end
                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleTouchEnd, { once: true }); // Remove after firing once
            }
        }

        function handleTouchMove(event) {
            event.preventDefault(); // Prevent scrolling during drag

            if (isDragging && event.touches.length === 1) {
                const touch = event.touches[0];
                handleDragMove(touch.clientX, touch.clientY); // Use unified move logic
            }
        }

        function handleTouchEnd(event) {
            event.preventDefault();

            if (isDragging) {
                // currentDropTarget should be set by the last touchmove
                if (currentDropTarget) {
                    processDrop(currentDropTarget); // Process drop on the highlighted target
                } else {
                    cleanupDragState(); // No target, just cleanup
                }
            }
             // Ensure global listeners are removed even if something went wrong
             document.removeEventListener('touchmove', handleTouchMove);
             // touchend listener removes itself with { once: true }
        }


        // --- Calculation and State Update ---
        function clearExpressionSlots() {
            operand1Slot.innerHTML = '';
            operatorSlot.innerHTML = '';
            operand2Slot.innerHTML = '';
            expression = { operand1: null, operator: null, operand2: null };
            // Remove any lingering highlights
            expressionSlots.forEach(slot => slot.classList.remove('drag-over'));
        }

        function checkAndCalculate() {
            if (expression.operand1 && expression.operator && expression.operand2) {
                let result;
                const op1 = expression.operand1;
                const op2 = expression.operand2;

                switch (expression.operator) {
                    case '+': result = op1.add(op2); break;
                    case '-': result = op1.subtract(op2); break;
                    case '*': result = op1.multiply(op2); break;
                    case '/': result = op1.divide(op2); break;
                    default:
                         cleanupDragState(); // Clear if invalid state
                         return;
                }

                // Handle division by zero or other errors
                if (isNaN(result.real.num) || isNaN(result.imag.num)){
                     showMessage("错误：除数不能为零！", null, true);
                     setTimeout(clearExpressionSlots, 1000); // Clear after showing message
                     return; // Stop further processing
                }

                // Attempt to add the result to the table
                const isNew = addNumberToTable(result);

                if (isNew) {
                    showMessage("恭喜你发现新数!", "images/Thumb.png", true);
                } else {
                     // Check if it failed because it exists or because table is full
                    if (discoveredNumbers.some(n => n.equals(result))) {
                         showMessage("已存在该数了哦", null, true);
                    }
                     // addNumberToTable already shows "Table full" message if needed
                }

                // Clear expression slots after a short delay
                setTimeout(clearExpressionSlots, 500); // Give a bit longer to see message
            }
             // If calculation wasn't possible (e.g., missing parts), do nothing yet.
             // The state remains until the next drop.
        }

        // --- Initialization ---
        startGameButton.addEventListener('click', startGame);

    </script>
</body>
</html>
